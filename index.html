<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Essentials - Quiz Q/A</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --bg: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #0d1117;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #334155;
            --success: #22c55e;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.7;
            padding: 2rem 1rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
        }

        header p {
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        .section {
            margin-bottom: 3rem;
        }

        .section-title {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .question-card {
            background: var(--bg-card);
            border-radius: 12px;
            margin-bottom: 1.25rem;
            border: 1px solid var(--border);
            overflow: hidden;
            transition: border-color 0.2s;
        }

        .question-card:hover {
            border-color: var(--primary);
        }

        .question-header {
            padding: 1.25rem 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .question-header:hover {
            background: rgba(99, 102, 241, 0.1);
        }

        .question-title {
            font-weight: 600;
            font-size: 1.05rem;
            padding-right: 1rem;
        }

        .toggle-icon {
            font-size: 1.5rem;
            color: var(--primary);
            transition: transform 0.3s;
            flex-shrink: 0;
        }

        .question-card.open .toggle-icon {
            transform: rotate(45deg);
        }

        .answer {
            display: none;
            padding: 0 1.5rem 1.5rem;
            border-top: 1px solid var(--border);
        }

        .question-card.open .answer {
            display: block;
        }

        .answer p {
            margin: 1rem 0;
        }

        .answer strong {
            color: var(--primary);
        }

        .answer ul, .answer ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }

        .answer li {
            margin: 0.5rem 0;
        }

        pre {
            background: var(--bg-code);
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            border: 1px solid var(--border);
            font-size: 0.9rem;
        }

        code {
            font-family: 'Fira Code', 'Consolas', monospace;
            color: #7dd3fc;
        }

        p code {
            background: var(--bg-code);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.95rem;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid var(--border);
        }

        th {
            background: var(--bg);
            color: var(--primary);
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.2);
        }

        .alert {
            background: rgba(245, 158, 11, 0.1);
            border-left: 4px solid var(--warning);
            padding: 1rem;
            border-radius: 0 8px 8px 0;
            margin: 1rem 0;
        }

        .alert-title {
            color: var(--warning);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        blockquote {
            border-left: 4px solid var(--primary);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-muted);
            font-style: italic;
        }

        .checklist {
            margin-top: 2rem;
            padding: 1.5rem;
            background: var(--bg-card);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .checklist h3 {
            color: var(--success);
            margin-bottom: 1rem;
        }

        .checklist label {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            cursor: pointer;
        }

        .checklist input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: var(--success);
        }

        .progress-bar {
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            margin-top: 1rem;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), #4ade80);
            width: 0%;
            transition: width 0.3s;
            border-radius: 4px;
        }

        .cheatsheet {
            margin-top: 2rem;
        }

        .cheatsheet summary {
            cursor: pointer;
            padding: 1rem;
            background: var(--bg-card);
            border-radius: 8px;
            font-weight: 600;
            color: var(--primary);
            border: 1px solid var(--border);
        }

        .cheatsheet summary:hover {
            background: rgba(99, 102, 241, 0.1);
        }

        .cheatsheet-content {
            padding: 1.5rem;
            background: var(--bg-card);
            border-radius: 0 0 8px 8px;
            border: 1px solid var(--border);
            border-top: none;
            margin-top: -4px;
        }

        .cheatsheet-content h4 {
            color: var(--primary);
            margin: 1.5rem 0 0.75rem;
        }

        .cheatsheet-content h4:first-child {
            margin-top: 0;
        }

        footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
            color: var(--text-muted);
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.75rem;
            }

            .question-header {
                padding: 1rem;
            }

            .answer {
                padding: 0 1rem 1rem;
            }

            table {
                font-size: 0.8rem;
            }

            th, td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Network Essentials - Quiz Q/A</h1>
            <p>Quiz para testar sua compreensao dos conceitos de networking essenciais para System Design Interviews</p>
        </header>

        <!-- Camadas de Rede e Modelo OSI -->
        <section class="section">
            <h2 class="section-title">ğŸ“¡ Camadas de Rede e Modelo OSI</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q1: Por que o modelo de camadas e tao importante para desenvolvedores de aplicacoes?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p>O modelo de camadas funciona como uma <strong>abstracao</strong> que simplifica drasticamente nosso trabalho. Cada camada esconde a complexidade das camadas inferiores, permitindo que:</p>
                    <ul>
                        <li>Voce nao precise saber quais voltagens representam 1 ou 0 no cabo de rede</li>
                        <li>Possa usar apenas a camada imediatamente abaixo (como usar <code>open()</code> sem instruir o disco manualmente)</li>
                        <li>Foque apenas no que e relevante para sua aplicacao</li>
                    </ul>
                    <p>E como usar uma API de alto nivel: voce chama <code>fetch()</code> e nao precisa implementar TCP handshakes manualmente.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q2: Quais sao as 3 camadas mais importantes para System Design Interviews e qual e a responsabilidade de cada uma?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <table>
                        <thead>
                            <tr>
                                <th>Camada</th>
                                <th>Protocolo Principal</th>
                                <th>Responsabilidade</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Layer 3 (Network)</strong></td>
                                <td>IP</td>
                                <td>Roteamento, enderecamento, quebra em pacotes, entrega "best-effort"</td>
                            </tr>
                            <tr>
                                <td><strong>Layer 4 (Transport)</strong></td>
                                <td>TCP, UDP, QUIC</td>
                                <td>Comunicacao end-to-end, confiabilidade, ordenacao, controle de fluxo</td>
                            </tr>
                            <tr>
                                <td><strong>Layer 7 (Application)</strong></td>
                                <td>HTTP, DNS, WebSockets</td>
                                <td>Protocolos de aplicacao que abstraem comunicacao para tipos especificos de dados</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>A Layer 3 garante que os pacotes cheguem ao destino, Layer 4 adiciona garantias sobre <em>como</em> chegam, e Layer 7 define <em>o que</em> esta sendo comunicado.</p>
                </div>
            </div>
        </section>

        <!-- Protocolos de Transporte -->
        <section class="section">
            <h2 class="section-title">ğŸ”Œ Protocolos de Transporte: TCP vs UDP</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q3: Uma empresa de streaming de jogos esta decidindo entre TCP e UDP para transmitir video em tempo real. Qual protocolo voce recomendaria e por que?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>UDP e a escolha correta</strong> para streaming de video em tempo real. Razoes:</p>
                    <ol>
                        <li><strong>Latencia e critica</strong> - Em jogos, milissegundos importam</li>
                        <li><strong>Perda de pacotes e aceitavel</strong> - Um frame perdido e menos problematico que atraso</li>
                        <li><strong>Sem overhead de handshake</strong> - Conexao mais rapida</li>
                        <li><strong>Sem retransmissao</strong> - Nao faz sentido retransmitir um frame de 2 segundos atras</li>
                    </ol>
                    <p>O TCP causaria "buffering" constante porque tentaria retransmitir pacotes perdidos, enquanto UDP permite que o cliente simplesmente ignore frames perdidos e continue mostrando os mais recentes.</p>
                    <div class="alert">
                        <div class="alert-title">âš ï¸ Cuidado</div>
                        <p>Se a aplicacao tambem tiver usuarios web (browser), WebRTC seria necessario pois browsers nao suportam UDP diretamente exceto via WebRTC.</p>
                    </div>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q4: O que significa dizer que TCP e "connection-oriented" e por que isso importa?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p>"Connection-oriented" significa que TCP estabelece uma <strong>conexao dedicada</strong> (chamada "stream") antes de transferir dados atraves do three-way handshake:</p>
                    <pre><code>1. SYN     â†’ Cliente solicita conexao
2. SYN-ACK â†’ Servidor reconhece e aceita
3. ACK     â†’ Cliente confirma estabelecimento</code></pre>
                    <p><strong>Por que importa:</strong></p>
                    <ul>
                        <li><strong>Ordenacao garantida</strong>: Mensagens na mesma conexao chegam em ordem</li>
                        <li><strong>Confiabilidade</strong>: Receptor confirma recebimento (ACK), se nao confirmar, ha retransmissao</li>
                        <li><strong>Estado mantido</strong>: Servidor e cliente "sabem" um do outro durante a sessao</li>
                        <li><strong>Controle de fluxo</strong>: Evita sobrecarregar o receptor</li>
                    </ul>
                    <p>E como uma ligacao telefonica: voce precisa "conectar" antes de falar, mas depois a comunicacao e continua e ordenada.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q5: Complete a tabela comparativa TCP vs UDP</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <table>
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>UDP</th>
                                <th>TCP</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Conexao</td>
                                <td>Connectionless</td>
                                <td>Connection-oriented</td>
                            </tr>
                            <tr>
                                <td>Confiabilidade</td>
                                <td>Best-effort (pode perder)</td>
                                <td>Entrega garantida</td>
                            </tr>
                            <tr>
                                <td>Ordenacao</td>
                                <td>Sem garantia de ordem</td>
                                <td>Mantem ordem</td>
                            </tr>
                            <tr>
                                <td>Header Size</td>
                                <td>8 bytes</td>
                                <td>20-60 bytes</td>
                            </tr>
                            <tr>
                                <td>Use Cases</td>
                                <td>Streaming, gaming, VoIP, DNS</td>
                                <td>Todo o resto (web, APIs, etc.)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Insight</strong>: O header menor do UDP (8 vs 20-60 bytes) contribui para sua maior velocidade, mas o custo e a falta de garantias.</p>
                </div>
            </div>
        </section>

        <!-- Protocolos de Aplicacao -->
        <section class="section">
            <h2 class="section-title">ğŸŒ Protocolos de Aplicacao</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q6: Por que HTTP e considerado "stateless" e por que isso e geralmente uma coisa boa para System Design?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Stateless significa</strong>: Cada requisicao e independente - o servidor nao precisa manter informacao sobre requisicoes anteriores.</p>
                    <p><strong>Por que e bom:</strong></p>
                    <ol>
                        <li><strong>Escalabilidade horizontal</strong> - Qualquer servidor pode responder qualquer requisicao</li>
                        <li><strong>Simplicidade</strong> - Servidores podem ser tratados como funcoes puras <code>f(request) â†’ response</code></li>
                        <li><strong>Resiliencia</strong> - Se um servidor cair, outro assume sem perda de "estado"</li>
                        <li><strong>Load balancing facilitado</strong> - Round-robin funciona perfeitamente</li>
                    </ol>
                    <p><strong>Principio de design</strong>: Minimize a superficie de estado no seu sistema. Quanto menos estado, mais facil escalar e recuperar de falhas.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q7: Voce esta projetando uma API para um app mobile que precisa mostrar perfil do usuario, posts recentes e lista de amigos em uma unica tela. Qual paradigma de API (REST, GraphQL, gRPC) voce escolheria e por que?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>GraphQL e a melhor escolha</strong> para este cenario.</p>
                    <p><strong>O problema com REST:</strong></p>
                    <ul>
                        <li><strong>Under-fetching</strong>: Precisaria de 3+ requests (GET /user, GET /posts, GET /friends)</li>
                        <li><strong>Over-fetching</strong>: Cada endpoint retornaria campos desnecessarios</li>
                        <li><strong>Latencia</strong>: Multiplos round-trips em conexao mobile = UX ruim</li>
                    </ul>
                    <p><strong>Por que GraphQL:</strong></p>
                    <pre><code>query {
  user(id: "123") {
    name
    avatar
    posts(limit: 5) {
      title
      thumbnail
    }
    friends(limit: 10) {
      name
      avatar
    }
  }
}</code></pre>
                    <ul>
                        <li><strong>Uma unica request</strong> busca exatamente o necessario</li>
                        <li><strong>Frontend itera rapidamente</strong> sem depender de mudancas no backend</li>
                        <li><strong>Menor payload</strong> = menos dados transferidos em rede movel</li>
                    </ul>
                    <p><strong>Quando NAO usar GraphQL:</strong></p>
                    <ul>
                        <li>Em entrevistas com requisitos fixos (nao ha iteracao)</li>
                        <li>Quando otimizacao de queries especificas e mais importante</li>
                    </ul>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q8: Por que gRPC nao e recomendado para APIs publicas/externas, mas e excelente para comunicacao interna entre servicos?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Para APIs internas (âœ… gRPC brilha):</strong></p>
                    <ul>
                        <li><strong>Performance</strong>: Protocol Buffers sao ~10x mais eficientes que JSON</li>
                        <li><strong>Tipagem forte</strong>: Erros pegos em compile-time, nao runtime</li>
                        <li><strong>Streaming bidirecional</strong>: Suporte nativo</li>
                        <li><strong>Geracao de codigo</strong>: Stubs para multiplas linguagens</li>
                        <li><strong>Voce controla ambos os lados</strong>: Pode garantir compatibilidade</li>
                    </ul>
                    <p><strong>Para APIs externas (âŒ Evitar gRPC):</strong></p>
                    <ul>
                        <li><strong>Protocolo binario</strong>: Dificil debugar com ferramentas comuns (curl, Postman)</li>
                        <li><strong>Tooling imaturo</strong>: Menos suporte em diversas linguagens/frameworks</li>
                        <li><strong>Browsers nao suportam</strong>: Nao funciona diretamente na web</li>
                        <li><strong>Documentacao</strong>: REST com OpenAPI e mais acessivel para terceiros</li>
                    </ul>
                    <p><strong>Padrao recomendado:</strong></p>
                    <pre><code>[Clientes externos] --REST/JSON--> [API Gateway] --gRPC--> [Microservicos internos]</code></pre>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q9: Qual a diferenca fundamental entre SSE (Server-Sent Events) e WebSockets? Quando usar cada um?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <table>
                        <thead>
                            <tr>
                                <th>Aspecto</th>
                                <th>SSE</th>
                                <th>WebSockets</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Direcao</strong></td>
                                <td>Unidirecional (server â†’ client)</td>
                                <td>Bidirecional</td>
                            </tr>
                            <tr>
                                <td><strong>Protocolo</strong></td>
                                <td>HTTP (hack elegante)</td>
                                <td>Protocolo proprio (upgrade de HTTP)</td>
                            </tr>
                            <tr>
                                <td><strong>Reconexao</strong></td>
                                <td>Automatica (built-in)</td>
                                <td>Manual</td>
                            </tr>
                            <tr>
                                <td><strong>Complexidade infra</strong></td>
                                <td>Baixa</td>
                                <td>Alta (firewalls, proxies, LBs)</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>Use SSE quando:</strong></p>
                    <ul>
                        <li>Apenas o servidor precisa "empurrar" dados</li>
                        <li>Notificacoes, feeds em tempo real, precos de leilao</li>
                        <li>Quer simplicidade operacional</li>
                    </ul>
                    <p><strong>Use WebSockets quando:</strong></p>
                    <ul>
                        <li>Comunicacao bidirecional de alta frequencia e necessaria</li>
                        <li>Jogos multiplayer, chat, colaboracao em tempo real</li>
                        <li>O overhead de infraestrutura e justificavel</li>
                    </ul>
                    <div class="alert">
                        <div class="alert-title">âš ï¸ Alerta para entrevistas</div>
                        <blockquote>"Launching into a WebSocket implementation without justifying why they are needed is a great way to get a thumbs down."</blockquote>
                        <p>WebSockets requerem infraestrutura cara e conexoes stateful - so use quando realmente precisar!</p>
                    </div>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q10: O que e WebRTC e por que ele e "pain to get right"?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>WebRTC</strong> permite comunicacao <strong>peer-to-peer</strong> direta entre browsers, sem servidor intermediario para dados. Perfeito para videochamadas.</p>
                    <p><strong>Por que e complexo:</strong></p>
                    <p><strong>1. NAT Traversal</strong>: A maioria dos usuarios esta atras de NAT, nao aceitam conexoes de entrada</p>
                    <ul>
                        <li><strong>STUN</strong>: Tecnicas como "hole punching" para descobrir IP publico</li>
                        <li><strong>TURN</strong>: Servidor relay como fallback quando P2P falha</li>
                    </ul>
                    <p><strong>2. Multiplas etapas de conexao:</strong></p>
                    <pre><code>1. Conectar ao signaling server
2. Obter IP publico via STUN
3. Trocar info via signaling
4. Estabelecer conexao P2P
5. (Fallback para TURN se falhar)</code></pre>
                    <p><strong>3. Unico protocolo L7 que usa UDP</strong> - mais rapido, mas menos confiavel</p>
                    <p><strong>Quando usar:</strong></p>
                    <ul>
                        <li>âœ… Videochamadas e conferencias</li>
                        <li>âœ… Audio em tempo real</li>
                        <li>âŒ Quase todo o resto (nao force P2P onde nao precisa!)</li>
                    </ul>
                    <blockquote>"I've seen more candidates go wildly off trail trying to design peer-to-peer systems using WebRTC than I have seen them successfully implement them."</blockquote>
                </div>
            </div>
        </section>

        <!-- Load Balancing -->
        <section class="section">
            <h2 class="section-title">âš–ï¸ Load Balancing</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q11: Explique a diferenca entre client-side load balancing e server-side (dedicated) load balancing. De um exemplo real de cada.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Client-Side Load Balancing:</strong> O cliente decide para qual servidor enviar a requisicao.</p>
                    <p><em>Exemplo: Redis Cluster</em></p>
                    <pre><code>1. Cliente pergunta a qualquer no sobre topologia do cluster
2. Cliente recebe lista de nos e shards
3. Cliente faz hash da key â†’ determina shard â†’ escolhe no
4. Cliente conecta DIRETAMENTE ao no correto</code></pre>
                    <ul>
                        <li>âœ… Muito rapido (sem hop adicional)</li>
                        <li>âœ… Eficiente para servicos internos (gRPC tem built-in)</li>
                        <li>âŒ Requer que cliente seja "inteligente"</li>
                        <li>âŒ Atualizacoes podem ser lentas para muitos clientes</li>
                    </ul>
                    <p><strong>Dedicated Load Balancer:</strong> Servidor/dispositivo intermediario toma a decisao.</p>
                    <p><em>Exemplo: AWS ALB (Application Load Balancer)</em></p>
                    <pre><code>Client â†’ ALB â†’ Backend Server</code></pre>
                    <ul>
                        <li>âœ… Clientes simples</li>
                        <li>âœ… Atualizacoes instantaneas</li>
                        <li>âœ… Controle granular (routing por URL, headers, etc.)</li>
                        <li>âŒ Hop adicional em cada request</li>
                    </ul>
                    <p><strong>DNS como client-side LB:</strong> DNS retorna IPs em ordem rotacionada - cada cliente recebe ordem diferente, distribuindo carga naturalmente. Tambem evita SPOF: 2 LBs em regioes diferentes + DNS = alta disponibilidade.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q12: Voce esta projetando um sistema com WebSockets para um chat em tempo real. Qual tipo de load balancer (L4 ou L7) voce usaria e por que?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>L4 (Layer 4) Load Balancer</strong> e a escolha correta para WebSockets.</p>
                    <p><strong>Por que:</strong></p>
                    <table>
                        <thead>
                            <tr>
                                <th>L4 Load Balancer</th>
                                <th>L7 Load Balancer</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Opera no nivel TCP/UDP</td>
                                <td>Opera no nivel HTTP</td>
                            </tr>
                            <tr>
                                <td><strong>Mantem conexao persistente</strong> clientâ†”server</td>
                                <td>Termina conexao e cria nova</td>
                            </tr>
                            <tr>
                                <td>Minima inspecao de pacotes</td>
                                <td>Inspeciona conteudo (mais CPU)</td>
                            </tr>
                            <tr>
                                <td>Ideal para protocolos stateful</td>
                                <td>Ideal para HTTP stateless</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>O problema com L7 para WebSockets:</strong> WebSocket precisa de conexao persistente. L7 load balancers terminam a conexao HTTP e criam novas conexoes para backends - isso "quebra" a semantica do WebSocket.</p>
                    <p><strong>Algoritmo recomendado: Least Connections</strong> - Para conexoes persistentes (SSE, WebSocket), usar "Least Connections" evita que um servidor acumule gradualmente todas as conexoes ativas enquanto novos servidores ficam ociosos.</p>
                    <p><strong>Excecao</strong>: Alguns L7 modernos (como AWS ALB) suportam WebSocket explicitamente, mas L4 continua sendo a escolha mais segura e performatica.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q13: O que sao health checks e por que sao essenciais para alta disponibilidade?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Health Checks</strong> sao mecanismos que load balancers usam para verificar se backends estao saudaveis.</p>
                    <p><strong>Como funcionam:</strong></p>
                    <pre><code>Load Balancer --[periodic ping]--> Backend Server
                                      |
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â†“                                   â†“
              Resposta OK                         Sem resposta/Erro
                    â†“                                   â†“
         Continua recebendo              Removido do pool (failover)
              trafego</code></pre>
                    <p><strong>Tipos de Health Check:</strong></p>
                    <ul>
                        <li><strong>TCP</strong>: Verifica se servidor aceita conexoes (simples, eficiente)</li>
                        <li><strong>HTTP</strong>: Faz request e verifica status code (200 vs 500)</li>
                        <li><strong>Custom</strong>: Endpoint especifico que verifica dependencias (DB, cache, etc.)</li>
                    </ul>
                    <p><strong>Por que sao essenciais:</strong></p>
                    <ol>
                        <li><strong>Failover automatico</strong>: Trafego desviado sem intervencao humana</li>
                        <li><strong>Deteccao proativa</strong>: Identifica problemas antes dos usuarios</li>
                        <li><strong>Graceful degradation</strong>: Sistema continua funcionando com capacidade reduzida</li>
                    </ol>
                    <p><strong>Configuracoes tipicas:</strong></p>
                    <ul>
                        <li>Intervalo: 5-30 segundos</li>
                        <li>Threshold: 2-3 falhas consecutivas antes de remover</li>
                        <li>Timeout: 2-5 segundos por check</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Regionalizacao e Latencia -->
        <section class="section">
            <h2 class="section-title">ğŸŒ Regionalizacao e Latencia</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q14: A velocidade da luz e uma limitacao real? Explique o impacto pratico para sistemas globais.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Sim, e uma limitacao fisica real e significativa!</strong></p>
                    <p><strong>A matematica:</strong></p>
                    <ul>
                        <li>Luz em fibra optica: ~200,000 km/s (2/3 da velocidade no vacuo)</li>
                        <li>Nova York â†” Londres: ~5,600 km</li>
                        <li>Round-trip minimo teorico: <strong>~56ms</strong> (so propagacao fisica!)</li>
                    </ul>
                    <p><strong>Impacto pratico:</strong></p>
                    <pre><code>Latencia local (&lt;1ms):     [User] â†” [Server na mesma cidade]
Latencia continental (~30ms): [User] â†” [Server em outro estado]
Latencia intercontinental (~80ms+): [User] â†” [Server em outro continente]</code></pre>
                    <p><strong>Isso importa porque:</strong></p>
                    <ul>
                        <li>Cada query ao DB adiciona essa latencia</li>
                        <li>Multiplos round-trips se acumulam rapidamente</li>
                        <li>100ms+ e perceptivel para usuarios</li>
                    </ul>
                    <p><strong>Solucoes:</strong></p>
                    <ol>
                        <li><strong>CDNs</strong>: Cache na "edge" (centenas de cidades)</li>
                        <li><strong>Regional Partitioning</strong>: Dados proximos de onde sao usados</li>
                        <li><strong>Data Locality</strong>: Co-localizar computacao com dados</li>
                    </ol>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q15: Usando o exemplo do Uber, explique como Regional Partitioning resolve problemas de latencia.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Insight chave do Uber:</strong></p>
                    <blockquote>"Se estou em Miami, nunca vou querer um motorista que esta em Nova York."</blockquote>
                    <p><strong>Arquitetura Regional:</strong></p>
                    <pre><code>                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚         GLOBAL COORDINATION         â”‚
                    â”‚   (user accounts, payment, etc.)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â†“                            â†“                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  NORTHEAST    â”‚          â”‚   SOUTHEAST   â”‚          â”‚   SOUTHWEST   â”‚
â”‚ (NY datacenter)â”‚         â”‚ (Atlanta DC)  â”‚          â”‚  (LA DC)      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ - Drivers NY  â”‚          â”‚ - Drivers MIA â”‚          â”‚ - Drivers LA  â”‚
â”‚ - Riders NY   â”‚          â”‚ - Riders MIA  â”‚          â”‚ - Riders LA   â”‚
â”‚ - Local DB    â”‚          â”‚ - Local DB    â”‚          â”‚ - Local DB    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                    <p><strong>Beneficios:</strong></p>
                    <ol>
                        <li><strong>Queries locais</strong>: Usuario em Miami â†’ Servidor em Atlanta â†’ DB em Atlanta</li>
                        <li><strong>Escala reduzida</strong>: Milhoes globais â†’ milhares por regiao</li>
                        <li><strong>Latencia minima</strong>: Servidor e DB co-localizados</li>
                        <li><strong>Isolamento de falhas</strong>: Problema em uma regiao nao afeta outras</li>
                    </ol>
                    <p><strong>Quando aplicar:</strong></p>
                    <ul>
                        <li>Dados tem localidade geografica natural</li>
                        <li>Usuarios raramente precisam de dados de outras regioes</li>
                        <li>Volume global e muito grande para um unico cluster</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Tratamento de Falhas -->
        <section class="section">
            <h2 class="section-title">ğŸ”§ Tratamento de Falhas</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q16: O que significa "retry with exponential backoff" e por que o "jitter" e importante?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Exponential Backoff:</strong> Em vez de retry imediato, espere progressivamente mais:</p>
                    <pre><code>Tentativa 1: falhou â†’ espera 1s
Tentativa 2: falhou â†’ espera 2s
Tentativa 3: falhou â†’ espera 4s
Tentativa 4: falhou â†’ espera 8s
...</code></pre>
                    <p><strong>Por que exponencial:</strong></p>
                    <ul>
                        <li>Da tempo para sistema se recuperar</li>
                        <li>Reduz carga durante problemas</li>
                        <li>Evita "martelar" um servico em dificuldade</li>
                    </ul>
                    <p><strong>O problema sem jitter:</strong></p>
                    <pre><code>1000 clientes falham simultaneamente
Todos esperam 1s
1000 clientes retentam simultaneamente â† THUNDERING HERD!
Todos esperam 2s
...</code></pre>
                    <p><strong>Com Jitter (aleatoriedade):</strong></p>
                    <pre><code>Cliente A: espera 0.8s
Cliente B: espera 1.3s
Cliente C: espera 0.9s
...retries distribuidos ao longo do tempo</code></pre>
                    <p><strong>Formula comum:</strong></p>
                    <pre><code>sleep = min(cap, base * 2^attempt) + random(0, jitter)</code></pre>
                    <p><strong>Em entrevistas</strong>: "Retry with exponential backoff and jitter" e a frase magica que interviewers esperam ouvir.</p>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q17: Explique o conceito de idempotencia e por que e crucial para sistemas distribuidos. De um exemplo de implementacao.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Idempotencia</strong>: Uma operacao que pode ser executada multiplas vezes produzindo o mesmo resultado.</p>
                    <p><strong>Por que e crucial:</strong> Em sistemas distribuidos, nao sabemos se uma requisicao:</p>
                    <ul>
                        <li>Nunca chegou</li>
                        <li>Chegou mas resposta se perdeu</li>
                        <li>Foi processada parcialmente</li>
                    </ul>
                    <p>Sem idempotencia, retry pode causar:</p>
                    <pre><code>POST /payment {amount: $10}  â†’ Cobrou $10
[timeout - resposta perdida]
POST /payment {amount: $10}  â†’ Cobrou $10 DE NOVO!
Total: $20 ğŸ˜±</code></pre>
                    <p><strong>Implementacao com Idempotency Key:</strong></p>
                    <pre><code>POST /payment
Headers:
  Idempotency-Key: user123-2024-01-15-order456

Body:
  {amount: $10}</code></pre>
                    <p><strong>No servidor:</strong></p>
                    <pre><code>def process_payment(request):
    key = request.headers['Idempotency-Key']

    # Verifica se ja processou
    existing = cache.get(key)
    if existing:
        return existing.result  # Retorna resultado anterior

    # Marca como "em processamento"
    cache.set(key, status="processing")

    # Processa pagamento
    result = charge_card(request.body.amount)

    # Salva resultado
    cache.set(key, result=result, status="done")

    return result</code></pre>
                    <p><strong>Operacoes naturalmente idempotentes:</strong></p>
                    <ul>
                        <li>GET (leitura nao altera estado)</li>
                        <li>PUT (substituicao completa)</li>
                        <li>DELETE (deletar algo ja deletado = OK)</li>
                    </ul>
                    <p><strong>Operacoes que precisam de cuidado:</strong></p>
                    <ul>
                        <li>POST (criacao)</li>
                        <li>PATCH (incrementos: <code>balance += 10</code>)</li>
                    </ul>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q18: O que e um Circuit Breaker e como ele previne falhas em cascata? Desenhe o diagrama de estados.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Circuit Breaker</strong> e um padrao inspirado em disjuntores eletricos que protege seu sistema quando dependencias falham.</p>
                    <p><strong>O problema que resolve:</strong></p>
                    <pre><code>Servico A â†’ Servico B (morto)
    â†“
A espera timeout (30s) para cada request
    â†“
Requests acumulam em A
    â†“
A fica lento
    â†“
Clientes de A comecam a falhar
    â†“
CASCADING FAILURE ğŸ’¥</code></pre>
                    <p><strong>Diagrama de Estados:</strong></p>
                    <pre><code>                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     CLOSED      â”‚ â† Estado normal
                    â”‚ (requests OK)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    falhas > threshold
                             â”‚
                             â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      OPEN       â”‚ â† Requests falham imediatamente
                    â”‚  (fail fast)    â”‚   (sem tentar chamar servico)
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
                    timeout expira
                             â”‚
                             â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   HALF-OPEN     â”‚ â† Permite 1 request de teste
                    â”‚ (testing...)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â†“                              â†“
         sucesso                          falha
              â†“                              â†“
         â†’ CLOSED                        â†’ OPEN</code></pre>
                    <p><strong>Beneficios:</strong></p>
                    <ol>
                        <li><strong>Fail Fast</strong>: Resposta imediata em vez de timeout longo</li>
                        <li><strong>Reduz carga</strong>: Para de "martelar" servico em problemas</li>
                        <li><strong>Self-healing</strong>: Testa recuperacao automaticamente</li>
                        <li><strong>Isolamento</strong>: Falha em B nao derruba A</li>
                    </ol>
                    <p><strong>Onde aplicar:</strong></p>
                    <ul>
                        <li>Chamadas a APIs externas</li>
                        <li>Conexoes de banco de dados</li>
                        <li>Comunicacao entre microservicos</li>
                        <li>Qualquer operacao de rede que pode falhar</li>
                    </ul>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q19: Descreva o cenario "thundering herd" e como circuit breakers ajudam a preveni-lo.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Thundering Herd (Manada Trovejante):</strong> Quando muitos clientes tentam acessar um recurso simultaneamente apos ele se tornar disponivel (ou tentar se recuperar).</p>
                    <p><strong>Cenario classico:</strong></p>
                    <pre><code>1. Database cai
2. 10,000 requests ficam esperando/retentando
3. Database comeca a subir (1 instancia)
4. 10,000 requests ATACAM a instancia nascente
5. Instancia nao aguenta e cai
6. GOTO 3 (loop infinito de morte)</code></pre>
                    <p><strong>Como Circuit Breakers ajudam:</strong></p>
                    <pre><code>ANTES (sem circuit breaker):
[10,000 clients] --retry--> [DB tentando subir] ğŸ’€

DEPOIS (com circuit breaker):
[10,000 clients] --X BLOCKED (circuit OPEN)
                           |
              [Apenas 1 request de teste passa]
                           |
                    [DB sobe com calma]
                           |
              [Teste OK â†’ Circuit CLOSES]
                           |
[Trafego liberado gradualmente]</code></pre>
                    <p><strong>Tecnicas complementares:</strong></p>
                    <ol>
                        <li><strong>Jitter nos retries</strong>: Requests nao sincronizados</li>
                        <li><strong>Rate limiting</strong>: Limite requests por segundo</li>
                        <li><strong>Gradual ramp-up</strong>: Liberar trafego progressivamente</li>
                        <li><strong>Bulkhead pattern</strong>: Isolar pools de conexao</li>
                    </ol>
                    <blockquote>"Experienced engineers who have spent time oncall will have a lot of war stories about cascading failures. It's a common problem that usually goes unnoticed until it bites you at 3am."</blockquote>
                </div>
            </div>
        </section>

        <!-- Questoes de Cenario -->
        <section class="section">
            <h2 class="section-title">ğŸ¯ Questoes de Cenario (Nivel Senior)</h2>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q20: Voce esta projetando o sistema de notificacoes em tempo real do Facebook (reacoes em lives, comentarios). Como voce arquitetaria considerando milhoes de usuarios simultaneos?</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Analise do problema:</strong></p>
                    <ul>
                        <li>Milhoes de viewers simultaneos por live popular</li>
                        <li>Reacoes sao "fire and forget" (perder algumas e OK)</li>
                        <li>Alta frequencia de eventos</li>
                        <li>Precisa de tempo real (baixa latencia)</li>
                    </ul>
                    <p><strong>Arquitetura proposta:</strong></p>
                    <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        VIEWERS                               â”‚
â”‚  [Browser/SSE] [Browser/SSE] [App/UDP] [App/UDP]            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    L7 LOAD BALANCER                          â”‚
â”‚              (para browsers via HTTP/SSE)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 NOTIFICATION SERVERS                         â”‚
â”‚   [Batching + Aggregation por live_id]                      â”‚
â”‚   - Agrupa reacoes em janelas de 100ms                      â”‚
â”‚   - Comprime: "â¤ï¸ x 5000, ğŸ˜‚ x 2000"                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              MESSAGE QUEUE (Kafka por live_id)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 REACTION INGESTION                           â”‚
â”‚   [Aceita UDP de apps, HTTP de browsers]                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
                    <p><strong>Decisoes chave:</strong></p>
                    <p><strong>1. Dual protocol:</strong></p>
                    <ul>
                        <li>Apps nativos: UDP (mais rapido, perda OK)</li>
                        <li>Browsers: HTTP batched (limitacao da plataforma)</li>
                    </ul>
                    <p><strong>2. SSE para push</strong> (nao WebSocket):</p>
                    <ul>
                        <li>Unidirecional e suficiente (server â†’ client)</li>
                        <li>Menos overhead de infraestrutura</li>
                        <li>Reconexao automatica</li>
                    </ul>
                    <p><strong>3. Batching agressivo:</strong></p>
                    <ul>
                        <li>Nao envia cada reacao individual</li>
                        <li>Agrega por janela de tempo</li>
                        <li>"5000 coracoes" e mais eficiente que 5000 mensagens</li>
                    </ul>
                    <p><strong>4. Regional partitioning:</strong></p>
                    <ul>
                        <li>Cada live tem "home region"</li>
                        <li>Viewers conectam ao edge mais proximo</li>
                        <li>Reacoes agregadas centralmente, distribuidas para edges</li>
                    </ul>
                </div>
            </div>

            <div class="question-card">
                <div class="question-header">
                    <span class="question-title">Q21: "O que acontece quando voce digita google.com no browser e pressiona Enter?" - Explique o fluxo completo de networking.</span>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="answer">
                    <p><strong>Fluxo completo:</strong></p>
                    <pre><code>1. DNS RESOLUTION
   Browser â†’ DNS Resolver: "Qual IP de google.com?"
   DNS Resolver â†’ Browser: "142.250.80.46"

2. TCP HANDSHAKE (3-way)
   Client â†’ Server: SYN (quero conectar)
   Server â†’ Client: SYN-ACK (aceito, tambem quero)
   Client â†’ Server: ACK (confirmado!)
   [Conexao TCP estabelecida]

3. TLS HANDSHAKE (para HTTPS)
   - Troca de certificados
   - Negociacao de cipher suite
   - Estabelecimento de chaves simetricas
   [Canal criptografado estabelecido]

4. HTTP REQUEST
   GET / HTTP/1.1
   Host: google.com
   User-Agent: Chrome/...
   Accept: text/html

5. SERVER PROCESSING
   - Load balancer recebe
   - Roteia para servidor disponivel
   - Servidor processa e gera resposta
   (âš¡ Unica parte que a maioria dos SWEs controla!)

6. HTTP RESPONSE
   HTTP/1.1 200 OK
   Content-Type: text/html
   [HTML do Google]

7. RENDERING
   - Browser parseia HTML
   - Requisita CSS, JS, imagens (mais requests!)
   - Renderiza pagina

8. TCP TEARDOWN (4-way) - quando conexao fecha
   Client â†’ Server: FIN
   Server â†’ Client: ACK
   Server â†’ Client: FIN
   Client â†’ Server: ACK</code></pre>
                    <p><strong>Camadas envolvidas:</strong></p>
                    <ul>
                        <li><strong>L7 (Application)</strong>: HTTP, DNS, TLS</li>
                        <li><strong>L4 (Transport)</strong>: TCP handshake/teardown</li>
                        <li><strong>L3 (Network)</strong>: IP routing entre redes</li>
                        <li><strong>L2/L1</strong>: Frames, sinais fisicos</li>
                    </ul>
                    <p><strong>Pergunta classica de entrevista</strong> - mostra entendimento end-to-end do stack de rede!</p>
                </div>
            </div>
        </section>

        <!-- Cheat Sheet -->
        <section class="section">
            <h2 class="section-title">ğŸ“‹ Resumo de Decisoes para Entrevistas</h2>

            <details class="cheatsheet">
                <summary>Ver Cheat Sheet Completo</summary>
                <div class="cheatsheet-content">
                    <h4>Protocolos de Transporte:</h4>
                    <table>
                        <thead>
                            <tr><th>Cenario</th><th>Escolha</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Default para tudo</td><td>TCP</td></tr>
                            <tr><td>Gaming/Streaming tempo real</td><td>UDP</td></tr>
                            <tr><td>Browsers + tempo real</td><td>WebRTC (unico UDP em browser)</td></tr>
                        </tbody>
                    </table>

                    <h4>APIs:</h4>
                    <table>
                        <thead>
                            <tr><th>Cenario</th><th>Escolha</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>API publica/externa</td><td>REST</td></tr>
                            <tr><td>Frontend flexivel/iterativo</td><td>GraphQL</td></tr>
                            <tr><td>Microservicos internos + performance</td><td>gRPC</td></tr>
                            <tr><td>Push notifications</td><td>SSE</td></tr>
                            <tr><td>Chat/Colaboracao bidirectional</td><td>WebSockets</td></tr>
                            <tr><td>Video/Audio calls</td><td>WebRTC</td></tr>
                        </tbody>
                    </table>

                    <h4>Load Balancers:</h4>
                    <table>
                        <thead>
                            <tr><th>Cenario</th><th>Escolha</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>HTTP APIs</td><td>L7</td></tr>
                            <tr><td>WebSockets</td><td>L4</td></tr>
                            <tr><td>Servicos internos controlados</td><td>Client-side</td></tr>
                            <tr><td>Alto throughput</td><td>Hardware LB</td></tr>
                        </tbody>
                    </table>

                    <h4>Algoritmos de LB:</h4>
                    <table>
                        <thead>
                            <tr><th>Cenario</th><th>Escolha</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Stateless services</td><td>Round Robin / Random</td></tr>
                            <tr><td>Conexoes persistentes (WS/SSE)</td><td>Least Connections</td></tr>
                            <tr><td>Session affinity</td><td>IP Hash</td></tr>
                        </tbody>
                    </table>

                    <h4>Tratamento de Falhas:</h4>
                    <table>
                        <thead>
                            <tr><th>Problema</th><th>Solucao</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Requests falham as vezes</td><td>Retry com exponential backoff + jitter</td></tr>
                            <tr><td>Retry pode duplicar acao</td><td>Idempotency keys</td></tr>
                            <tr><td>Servico downstream morto</td><td>Circuit breaker</td></tr>
                            <tr><td>Muitos clientes simultaneos</td><td>Rate limiting + bulkhead</td></tr>
                        </tbody>
                    </table>

                    <h4>Latencia Global:</h4>
                    <table>
                        <thead>
                            <tr><th>Problema</th><th>Solucao</th></tr>
                        </thead>
                        <tbody>
                            <tr><td>Assets estaticos</td><td>CDN</td></tr>
                            <tr><td>Dados com localidade natural</td><td>Regional partitioning</td></tr>
                            <tr><td>Dados globais, leitura pesada</td><td>Read replicas + cache distribuido</td></tr>
                        </tbody>
                    </table>
                </div>
            </details>
        </section>

        <!-- Auto-avaliacao -->
        <section class="section">
            <h2 class="section-title">ğŸ† Auto-avaliacao</h2>

            <div class="checklist">
                <h3>Apos completar o quiz, avalie seu conhecimento:</h3>
                <label><input type="checkbox" id="check1"> Consigo explicar as diferencas entre TCP e UDP e quando usar cada um</label>
                <label><input type="checkbox" id="check2"> Entendo os tradeoffs entre REST, GraphQL e gRPC</label>
                <label><input type="checkbox" id="check3"> Sei quando usar SSE vs WebSockets vs WebRTC</label>
                <label><input type="checkbox" id="check4"> Compreendo L4 vs L7 load balancing e suas implicacoes</label>
                <label><input type="checkbox" id="check5"> Posso explicar retry with exponential backoff e jitter</label>
                <label><input type="checkbox" id="check6"> Entendo idempotencia e como implementa-la</label>
                <label><input type="checkbox" id="check7"> Sei o que e um circuit breaker e quando aplica-lo</label>
                <label><input type="checkbox" id="check8"> Consigo discutir estrategias de regionalizacao (CDN, partitioning)</label>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p id="progressText" style="margin-top: 0.75rem; color: var(--text-muted); text-align: center;">0/8 completos</p>
            </div>
        </section>

        <footer>
            <p>Quiz criado com base no conteudo de Network Essentials para System Design Interviews</p>
        </footer>
    </div>

    <script>
        // Toggle question cards
        document.querySelectorAll('.question-header').forEach(header => {
            header.addEventListener('click', () => {
                const card = header.parentElement;
                card.classList.toggle('open');
            });
        });

        // Progress tracking
        const checkboxes = document.querySelectorAll('.checklist input[type="checkbox"]');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        function updateProgress() {
            const checked = document.querySelectorAll('.checklist input[type="checkbox"]:checked').length;
            const total = checkboxes.length;
            const percentage = (checked / total) * 100;

            progressFill.style.width = percentage + '%';
            progressText.textContent = `${checked}/${total} completos`;

            if (checked === total) {
                progressText.innerHTML = `<strong style="color: var(--success);">ğŸ‰ Voce esta pronto para System Design Interviews!</strong>`;
            }

            // Save to localStorage
            const state = Array.from(checkboxes).map(cb => cb.checked);
            localStorage.setItem('quizProgress', JSON.stringify(state));
        }

        // Load saved progress
        const savedProgress = localStorage.getItem('quizProgress');
        if (savedProgress) {
            const state = JSON.parse(savedProgress);
            checkboxes.forEach((cb, i) => {
                if (state[i]) cb.checked = true;
            });
            updateProgress();
        }

        checkboxes.forEach(cb => cb.addEventListener('change', updateProgress));
    </script>
</body>
</html>
